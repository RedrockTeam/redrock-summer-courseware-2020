

# 后端暑期培训第一节

## 架构模式

> 架构模式（摘自维基百科）
>
>  **架构模式**是[软件架构](https://zh.wikipedia.org/wiki/软件架构)中在给定环境下常遇到问题的通用的、可重用的解决方案。[[1\]](https://zh.wikipedia.org/wiki/架构模式#cite_note-TMD-1)类似于[软件设计模式](https://zh.wikipedia.org/wiki/软件设计模式)但覆盖范围更广，致力于[软件工程](https://zh.wikipedia.org/wiki/软件工程)中不同问题，如[计算机硬件](https://zh.wikipedia.org/wiki/计算机硬件)性能限制、[高可用性](https://zh.wikipedia.org/wiki/高可用性)、[业务风险](https://zh.wikipedia.org/wiki/风险)极小化。[[2\]](https://zh.wikipedia.org/wiki/架构模式#cite_note-2)[[3\]](https://zh.wikipedia.org/wiki/架构模式#cite_note-3)一些架构模式在[软件框架](https://zh.wikipedia.org/wiki/软件框架)被实现。 

一般其实我们在进行开发的时候不会先进行正式的**架构设计**，架构设计对于一些小型应用程序不会产生过多的问题，而对于一些中型或者大型应用程序，都是需要专门的架构师对整个应用程序进行全局的考量，且架构师的考量可能决定了整个应用程序的开发走向、性能走向，甚至能决定整个应用程序的生命周期。

没有清晰的架构设计，大部分程序员都是会选择采用**传统的分层的架构模式**，自然地将代码模块分隔成几个packge。但是这种做法经常导致未能好好组织代码模块，且缺乏清晰的角色、责任以及相互关系。这也经常被称为大泥球反模式。

> Big ball of mud（摘自维基百科）
>
>  A **big ball of mud** is a [software system](https://en.wikipedia.org/wiki/Software_system) that lacks a perceivable architecture. Although undesirable from a software engineering point of view, such systems are common in practice due to business pressures, developer [turnover](https://en.wikipedia.org/wiki/Turnover_(employment)) and [code entropy](https://en.wikipedia.org/wiki/Software_entropy). They are a type of design [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern). 
>
> Anti-pattern（摘自维基百科）
>
>  An **anti-pattern** is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. 

架构模式可以帮助你定义程序的**基本特征和行为**，例如 一些架构模式很自然让程序成为大规模的程序，有些模式让程序变得灵巧敏捷。

- 根据特定的业务需求和目标选择合适的架构

### 分层架构（Layered Architecture）

> 最通用的架构模式
>
> 也被叫做N层架构模式（ n-tier architecture pattern ）

分层架构能够贴合大部分应用程序所需要的架构风格。

- 层级结构能够将每一部分的**角色、责任及层级结构之间关系**变得清晰，各个层级都有各自的**约束**，各层级之间的关系都有一定的**规范**

#### 模式描述

简单描述来说，就是**将应用程序划分为几个层，每一层代表应用的一个功能，且每一层都有特定的角色和责任。**

大部分应用程序会分成**表现层、业务层、持久层和数据库层**，小的应用可能会将某些层级合并，而更大规模的应用程序可能划分更多的层，如中间件层。

![](http://img.zhengyua.cn/img/20200710203135.png)

- 分层架构的一个特性就是**关注分离（separation of concerns）**

  即每一层负责自己的逻辑，而不会去关注其他层的逻辑

#### 关键概念

因为每一层都是独立的，在分层结构中Request必须自顶向下经过每一层。

![](http://img.zhengyua.cn/img/20200710203356.png)

在分层架构中，每一层都是封闭的，这也是另一个特征：**层隔离（layers of isolation）**

即你对任意一层的改变都**不会影响到其他层**，且任意一层不必关注其它层的实现，只需关注如何进行交互。

- 这能让我们在开发时只关注某一层的编写，而不会去考虑其他层的实现方式是否会影响到该层的实现，对于其他层，我们只需要关注下一层或者上一层暴露出来的接口。这也能在我们排除和修改应用程序中出现的Bug，因为每一层是封闭的，所以我们通过分层来定位Bug位置非常清晰，且修改时其他层并不会影响到其他层。

当我们考虑层级之间的关系时，在分层架构下很容易**增加新的层**比较好理解，因为它不会对其它层产生影响。但是有时候我们可能会遇到某一层不必经过其中某一个层，而分层架构又要求必须经过这一层，这时候我们可以创建一个开放的层即可以绕过这一层直接访问下一层。

![](http://img.zhengyua.cn/img/20200710204902.png)

#### 架构例子

淘宝在前几年的架构设计中就是使用的分层架构。

![](http://img.zhengyua.cn/img/20200710204944.png)

#### 架构考量

对于大部分应用程序，分层架构是一个**可靠的通用的架构**。

但是在使用的时候我们需要注意几点

- **污水池反模式（ architecture sinkhole anti-pattern ）**

  简单来说，就是太过于注重分层标准，在请求时经过某一并没有太多的意义的层，如在服务层中，并没有做任何的业务逻辑，但是又必须调用服务层。

  遇到这种问题时，我们需要考虑这种请求的百分比是多少，根据80-20原则，当你的请求超过20%的时候就需要考虑让一些层变成开放的。

- **层规模过于庞大**

  当某一层的规模过于庞大时，我们可以考虑将这一层进行更细小的板块拆分，或者说可以将该层进行独立发布，即作为单独的一个应用程序发布。但涉及的问题，可能会涉及到分布式、健壮性、可靠性等。

### 事件驱动架构（Event-Driven Architecture）

事件驱动架构是一个流行的**分布式异步架构模式**，可以用来设计规模很大的应用程序。基于这种架构模式应用可大可小。 

它由**高度解耦的，单一目的事件组成，可以异步地接收和处理事件**。

它包括两个主要的拓扑结构：

- mediator
- broker

其主要区别在于mediator拓扑结构中会对事件队列进行一些额外操作并会划分成event channel对事件进行分别处理，而broker拓扑结构并不会做这些操作。

#### Mediator拓扑架构

mediator拓扑结构中包括四个组件：

- event queues
- event mediator
- event channels
- event processors

![](http://img.zhengyua.cn/img/20200710210257.png)

在Mediator拓扑结构中，会进行Event进行一系列处理，**其主要过程是**：

- 客户端发送一个事件（Event）到事件队列（event queues）中。
- EventMediator接收从事件队列中发来的事件，会发送额外的一些异步事件给event channels来执行处理的每个步骤。
- Event Processors监听event channels，接收事件并处理一些业务逻辑。

模式**没有限定事件队列的实现方式**，可能是消息队列、webService或者其他。

这里有两种事件：初始事件和处理事件。

**Mediator会将初始事件编排成处理事件**。它没有具体的业务逻辑，只是一个协调者，负责将初始事件转化成一个或者多个处理事件。 

**event channels** 既可以是消息队列，也可以是消息topic，**大部分是消息topic**，这样可以由多个消息处理器(event processor)处理同一个消息。 

消息处理器**包含实际的业务逻辑**。每个消息处理器都是自包含的，独立的，高度解耦的，执行单一的任务。 



#### Broker拓扑架构

Broker拓扑架构中并没有Mediator进行协调和编排。只包含了两个组件broker和event processor。

-  **所有的事件串联起来通过一个轻量级的消息broker**

![](http://img.zhengyua.cn/img/20200710211439.png)

**broker中的event channel**可以是消息队列，消息topic或者它们的复合形式。

**event processor**负责处理事件，发布新的事件 

#### 架构例子

![](http://img.zhengyua.cn/img/20200710211706.png)

微博在早期使用同步推模式，很容易会超出服务器负载。后来改用异步推拉结合的模式，在性能得到了质的提升。 

#### 架构考量

在事件驱动架构下，由于需要实现**异步和分布式的特性**，所以实现难度非常大。

分布式所带来的的问题放在任何应用程序中都是非常重要的部分，如数据同步问题、服务可用、容错机制等。

且**事件处理器的创建、维护和管理**，也是需要复杂的设计。

### 微内核架构（Microkernel Architecture）

微内核架构模式通常又被成为插件架构模式，可以用来实现基于产品的应用。

> 比如Eclipse，在微内核的基础上添加一些插件，就可以提供不同的产品，如C++, Java等。
>
> 微内核架构模式在操作系统中也有应用，如Windows，而Unix是单核架构。

#### 模式描述

微内核包含两个组件： **core system 和 plug-in modules**。

应用逻辑被分隔成核心系统和插件模块，可以提供可扩展的，灵活的，特性隔离的功能。 

![](http://img.zhengyua.cn/img/20200710212459.png)

#### 模式例子

-  Eclipse IDE 

#### 架构考量

- 微内核的架构模式可以**嵌入到其它的架构模式**之中

- 微内核架构通过插件还可以提供**逐步演化的功能和增量开发**



### 微服务架构

微服务架构重点就在于**面向服务架构**，目前许多大型的应用程序都逐渐走向微服务。这种模式还在持续发展中，目前还并没有一个权威解释和架构规范。

#### 模式描述

虽然微服务架构并没有确定的架构规范，但是有通用的核心概念应用在这种架构模式中。

- **分隔发布单元 （separately deployed units）**

  在中间的发布层单元层可以有不同的方式来实现，如API REST-based、Application REST-based和中心化消息。

  ![](http://img.zhengyua.cn/img/20200710213340.png)

- **分布式**

#### 架构考量

微服务架构是一种应对复杂性的产物，只有当问题复杂到一定程度的时候，他才是有益的。相比简单的问题，它本身就是复杂度过剩的。是不值得的。当前的技术方案，前一阶段的技术债都是存在的，正确的微服务微更应该是上一个阶段SOA的优化，是一种更节制、更加拥抱技术深层次内核—概念/领域问题/复杂性问题等产物。

## 期末考核

>  李辰宇海 —https://github.com/childifish/redrockmap 
>
>  张安顺 — https://github.com/z-anshun/yan/tree/master/final_exam 
>
>  张翔— https://github.com/ZXHoshinoSyou/Advance-Study/tree/master/SummerExam 
>
>  黄晨峰— https://github.com/sarailQAQ/wuzi 
>
>  沈怡然— https://github.com/flowerwedding/task 
>
>  刘欣玉—https://github.com/llllleapfrog/TCPchessgame.git 
>
>  邵泽森— https://github.com/loster-shao/redrocktest 
>
>  张彩嵘— https://github.com/RedRock-web/gobang
>
>  纪智鹏— https://github.com/ITAleftback/learn-git 
>
>  郑明鑫—https://github.com/haohanyuzmx/mywork 

###  李辰宇海 —https://github.com/childifish/redrockmap 1

- README
- 接口文档

- 项目结构
- Cookie
- error处理
- DB交互层与接口交互层放在一起
- 接口返回格式
- 注解信息
- 接口无返回信息
- 服务器部署服务

###  张安顺 — https://github.com/z-anshun/yan/tree/master/final_exam 1

- README
- 接口文档
- 项目仓库
- 数据库Table字段问题
- 接口返回格式封装
- 错误码
- 注释信息
- model层意义
- 结构体声明
- 日志打印信息规范
- 中间件层鉴权
- 魔法变量
- panic
- HasTable
- 跨域问题
- Cookie与Context
- Token凭证
- 防注入
- 登录状态验证
- Cookie验证问题
- 主线程协程阻塞操作
- 服务器部署

###  张翔—https://github.com/ZXHoshinoSyou/AdvanceStudy/tree/master/SummerExam 1

- 接口文档
- 项目仓库
- Group问题
- 账号密码作为动态路由
- MySQL客户端交互
- ID
- Fatal问题
- 专有词冲突
- 变量方法访问限制
- 注释信息
- 接口返回格式完全
- 错误码
- 返回错误信息
- 函数域
- log日志安全等级
- webscoket
- 结构体属性意义
- 服务器部署

### 黄晨峰— https://github.com/sarailQAQ/wuzi 1

- 接口文档
- README
- json格式
- token状态管理
- 注释信息
- flag使用
- 错误信息
- 客户端websocket连接
- 包命名规范
- 日志打印规范
- test文件
- 错误码
- MySQL连接设置空闲数、连接数

### 沈怡然— https://github.com/flowerwedding/task 1

- README
- 接口文档
- 包命名规范
- 接口Restful风格
- 文件命名规范
- gomod
- JWT库
- 注释信息
- 接口返回信息封装
- Session与Context
- 数据库层与接口层冲突
- websocket

### 刘欣玉—https://github.com/llllleapfrog/TCPchessgame.git 1

- 接口文档
- websocket
- 服务部署

### 纪智鹏— https://github.com/ITAleftback/learn-git  1

- 项目仓库
- 接口文档
- README
- MaxOpenConns
- 注释信息
- os.args使用
- Fatal
- jsonTag使用
- 重复关闭Socket
- 通道信息
- 用户名
- rpc返回数据类型
- syncMap使用
- 项目结构
- 数据库层与服务层交互冲突

### 邵泽森— https://github.com/loster-shao/redrocktest 1

- README
- 接口文档
- goMod
- 注释信息
- 死循环阻塞
- 接口返回信息规范
- 数据库连接
- 错误码
- 数据库层与接口层冲突
- Table自动迁移
- dbModel指针
- Cookie设置
- 注册路由格式
- 包命名格式
- gormModel使用
- 连接通道

### 张彩嵘— https://github.com/RedRock-web/gobang 1

- 接口文档
- 数据库关闭
- Next操作
- 数据库交互层冲突
- 注释信息
- 中间件冗余
- jwt使用意义

### 郑明鑫—https://github.com/haohanyuzmx/mywork 1

- 接口文档
- 错误处理
- 连接检查处理
- jsonTag使用
- 日志打印处理
- select使用
- 错误码使用
- 接口返回格式规范
- 项目结构
- 注册路由
- Cookie与Context
- 注册端口

## Go编码规范

每一种编程语言都会有相应编码规范。

编码规范是人们通过使用总结下来的，针对该语言的特性和性能、使用该语言编写项目规范等因素来考量。

这里给大家简单说一下由Uber所编写的Go风格规范，该规范已经初具规模，受到广大Gopher的关注。

- [Go编码规范]( https://github.com/xxjwxc/uber_go_guide_cn )



## 作业

- 作业一
  - 期末考核能够运行

- 作业二
  - Go编码规范总结

## 参考

https://colobu.com/2015/04/08/software-architecture-patterns/ 