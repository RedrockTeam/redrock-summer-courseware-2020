## Linux

### 一、linux系统目录结构

**/bin：**bin是Binary的缩写，此目录中存放着经常使用的命令

**/boot：**存放启动Linux时使用的一些核心文件。包括连接文件以及镜像文件

/dev：dev是Device(设备)的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的

**/etc：**存放所有的系统管理所需要的配置文件和子目录

**/home：**用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的

**/lib：**存放着系统最基本的动态连接共享库，几乎所有的应用程序都需要用到这些共享库 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件

/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下

/mnt：让用户临时挂载别的文件系统，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了

/opt：给主机额外安装软件所摆放的目录，比如安装Oracle数据库在此目录下，默认是空的

/proc：是一个虚拟的目录，它是系统内存的映射，可以通过直接访问这个目录来获取系统信息，这个目录的内容不在硬盘上而是在内存里

**/root：**该目录为系统管理员，也称作超级权限者的用户主目录

/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序

/selinux：这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的

/srv：存放一些服务启动之后需要提取的数据

**/sys：**该目录下安装了2.6内核中新出现的一个文件系统sysfs，sysfs文件系统集成了：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统

**/tmp：**存放一些临时文件

**/usr：**用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录 **/usr/bin：**系统用户使用的应用程序

/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序

/usr/src：内核源代码默认的放置目录

**/var：**存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。主要存放各种日志文件

/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除，如果你的系统上有 /var/run 目录，应该让它指向 run

### 二、Linux常用命令


ls: 列出目录

cd：切换目录

pwd：Print Working Directory，显示目前的目录

mkdir：创建一个新的目录

rmdir：删除一个空的目录

cp: 复制文件或目录，命令 cp/usr/text.txt/tmp/text1.txt将usr目录下的text.txt复制到tmp目录下，并重命名为text1.txt

rm: 移除文件或目录，命令 rm-f text.txt强制删除文件

mv：移动文件与目录，或修改名称，命令 mv/tmp/test.txt/usr将tmp目录下的test.txt文件移动到/usr目录下

cat：由第一行开始显示文件内容

tac：从最后一行开始显示，可以看出 tac 是 cat 的倒着写

nl：显示的时候，顺道输出行号

more：一页一页的显示文件内容

less：与 more 类似，但是比 more 更好的是，他可以往前翻页

head：只看头几行

tail：只看尾巴几行

vim或vi：编辑文件
Linux yum 命令


yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令 语法： yum[options][command][package...]

options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等

command：要进行的操作

package：操作的对象

**yum常用命令 yum check-update：列出所有可更新的软件清单命令**

yum update：更新所有软件

yum install<package_name>：安装指定的软件

yum update<package_name>：更新指定的软件

yum list：列出所有可安裝的软件清单

yum remove<package_name>：删除软件包

yum search：查找软件包

yum clean packages: 清除缓存目录下的软件包

yum clean headers: 清除缓存目录下的 headers

yum clean oldheaders: 清除缓存目录下旧的 headers

yum clean, yum clean all (= yum clean packages; yum clean oldheaders)：清除缓存目录下的软件包及旧的headers

## Docker

### 一、什么是Docker?

Docker时Docker.Lnc公司开源的一个基于LXC技术之上搭建的Container容器引擎，源代码托管在Github上，基于Go语言并遵从Apache2.0协议开源。 
Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。
Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。
总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

![img](https://images2018.cnblogs.com/blog/1011251/201806/1011251-20180609113423222-152077047.png)

### 二、Docker的概念

Docker是开发人员和系统管理员使用容器开发、部署和运行应用程序的平台。使用Linux容器来部署应用程序称为集装箱化。使用docker轻松部署应用程序。

集装箱化的优点：

- 灵活：即使是复杂的应用程序也可封装。
- 轻量级：容器利用并共享主机内核。
- 便携式：您可以在本地构建，部署到云上并在任何地方运行。
- 可扩展性：您可以增加和自动分发容器副本。
- 可堆叠：您可以垂直堆叠服务并及时并及时堆叠服务。



### 三、images和容器

通过运行images启动容器，一个images是一个可执行的包，其中包括运行应用程序所需要的所有内容-代码，运行时，库、环境变量和配置文件。
容器时images运行时示例-当被执行时(即，images状态，或者用户进程)在内存中，可以使用命令查看正在运行容器的列表docker ps,就像在Linux中一样。

### 四、虚拟机

虚拟机(virtual machine)就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其它部分毫无影响。

**虚拟机的缺点：**

- **资源占用多：**虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1M，虚拟机依然需要几百MB的内容才能运行。
- **冗余步骤多：**虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。
- **启动慢：**启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用陈故乡才能真正运行。

### **五、Linux容器**

由于虚拟机存在这个缺点，Linux发展出了另一种虚拟化技术：Linux容器(Linux Containers,缩写为LXC)。
Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。

- **启动快：**容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。
- **资源占用少：**容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所以资源。另外，多个容器可以共享资源，虚拟机都是独享资源。
- 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。

### 六、容器和虚拟机

一个容器中运行原生Linux和共享主机与其它容器的内核，它运行一个独立的进程，不占用任何其它可执行文件的内存，使其轻量化。

相比之下，虚拟机(VM)运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源多。

![img](https://images2018.cnblogs.com/blog/1011251/201806/1011251-20180610171525142-1923858765.png)

### 七、Docker产生的目的就是解决以下问题

- 环境管理复杂：从各种OS到各个中间件再到各种App,一款产品能够成功发布，作为开发者需要关心的东西太多，且难于管理，这个问题在软件兴业中普遍存在并需要直接面对。Docker可以简化部署多种应用实例工作，比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个image部署。
- 云时代的到来：AWS的成功，引到开发者将应用转移到云上，解决l硬件管理的问题，然而软件配置和管理相关的问题依然存在。Docker的出现正好能帮助软件开发者开阔思路，尝试新的软件管理的方法解决这个问题。
- 虚拟化手段的变化：云时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需分配的资源需求以及保证可用性和隔离性。然而无论是KVM还是Xen，在Docker看来都是在浪费资源，又难于管理，更加轻量级大LXC更加灵活和快速：
- LXC的便携性：LXC在Linux 2.6的Kernel里就已经存在了，但是其设计之初并非为云计算考虑，缺少标准化的描述手段和容器的可便携性，决定其构建出的环境难于分发和标准化管理(相对于KVM之类的image和sanpshot的概念)。Docker就在这个问题上作出了实质性的创新方法。

### 八、Docker的用途

Docker的主要用途，目前又三大类：

- **提供了一次性的环境：**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。
- **提供弹性的云服务：**因为Docker容器可以随开随关，很适合动态扩容和所容。
- **组建微服务架构：**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

### 九、基本概念

#### Docker镜像

```
操作系统分为内核和用户空间，对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个root文件系统。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
```

##### 分层存储

```
因为镜像包含系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层系统联合组成。
镜像构建时会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层，比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需要的内容，构建新的镜像。
```

#### Docker容器

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立宿主的系统下操作一样。这种特性使容器封装的应用比直接在宿主运行更加安全。
前面讲过镜像使用的是分层储存，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个味容器运行时读写而准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照Docker最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(volume)、或者绑定宿主目录，在这些位置的读写会跳过存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 仓库

##### Docker Registry

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。
一个Docker Registry中可以包含多个仓库(Repository);每个仓库可以包含多个标签(tag)；每个标签对应一个镜像。
通常，一个仓库会包含一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<仓库名>:<标签>的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以laest作为默认标签。
以ubuntu镜像为例，ubuntu是仓库的名字，其包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需要哪个版本的镜像。如果忽略了标签，比如ubuntu,那将视为ubuntu:latest。
仓库名经常以两段式路径形式出现，比如jwilder/nginx-proxy,前者意味着Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry的软件或服务。
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##### Docker Registry公开服务

```
Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。
最常使用的Registry公开服务是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。除此以外，还有CoreOS的Quay.io，CoreOS相关的镜像存储在这里；Google的Google Container Registry,Kubernetes的镜像使用的就是这个服务。
在国内访问这些服务可能会比较慢，郭恩ID饿一些云服务商题提供了针对Docker Hub的镜像服务(Registry Mirror),这些镜像服务被称为加速器。常见的有阿里云加速器、DaoCloud加速器等。使用加速器会直接从国内的地址下载Docker Hub的镜像，比直接从Docker Hub下载速度会提高很多。
```