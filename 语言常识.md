# 语言常识

## 语言👩‍👩‍👧‍👦

### 动态语言与静态语言

#### 动态语言

- 下面摘自维基百科：

  **动态编程语言**是[高级编程语言](https://zh.wikipedia.org/wiki/高级编程语言)的一个类别，在计算机科学领域已被广泛应用。它是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可+以被删除或是其他结构上的变化。动态语言目前非常具有活力。众所周知的[ECMAScript](https://zh.wikipedia.org/wiki/ECMAScript)（[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)）便是一个动态语言，除此之外如[PHP](https://zh.wikipedia.org/wiki/PHP)、[Ruby](https://zh.wikipedia.org/wiki/Ruby)、[Python](https://zh.wikipedia.org/wiki/Python)等也都属于动态语言，而[C](https://zh.wikipedia.org/wiki/C语言)、[C++](https://zh.wikipedia.org/wiki/C%2B%2B)等语言则不属于动态语言。

  大部分动态语言都使用动态类型，但也有些不是。

简单理解起来，动态语言是可以在运行的时候根据某些条件来改变自身条件，即在运行的时候可以“随机应变”。

#### 静态语言

静态与动态相对比，所以与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、Golang、C、C++、C#等。

### 动态类型语言与静态类型语言

动态语言与静态语言、静态类型语言与动态类型语言是完全不同的概念。

其前者突出的地方在于改变代码的结构，而后者突出点在于改变数据的类型。

#### 动态类型语言

动态类型语言简单理解起来就是在程序运行期间才会做数据类型检查的语言。

主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。

#### 静态类型语言

静态语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型。
主要语言：C、C++、C#、Java、Object-C。

### 强类型语言与弱类型语言

#### 强类型语言

*强类型strongly typed*: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。

简单来说就是使之强制数据类型定义的语言。

没有强制类型转化前，不允许两种不同类型的变量相互操作。强类型定义语言是类型安全的语言，如Java、C# 和 Python，比如Java中“int i = 0.0;”是无法通过编译的；

#### 弱类型语言

*弱类型weakly typed*: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors，故C是弱类型。

简单来说数据类型可以被忽略的语言。

与强类型语言相反, 一个变量可以赋不同数据类型的值，允许将一块内存看做多种类型，比如直接将整型变量与字符变量相加。C/C++、PHP都是弱类型语言，比如C++中“int i = 0.0;”是可以编译运行的；

> 注意，强类型语言在速度上略逊色于弱类型语言，使用弱类型语言可节省很多代码量，有更高的开发效率。而对于构建大型项目，使用强类型语言可能会比使用弱类型更加规范可靠。



![](http://img.zhengyua.cn/img/20200723202716.png)

### 编译型语言

> 下面摘自百度百科
>
> 运行编译型语言是相对于[解释型语言](https://baike.baidu.com/item/解释型语言/8888952)存在的，编译型语言的首先将源代码编译生成机器语言，再由机器运行[机器码](https://baike.baidu.com/item/机器码/86125)（[二进制](https://baike.baidu.com/item/二进制/361457)）。像C/C++等都是编译型语言。
>
> 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等.
>
> 而相对的,解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须**先解释再运行**。

编译型语言就是需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。

- 一般需经过编译（compile）、链接（linker）这两个步骤。

编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。

其优点在于编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。

而缺点就在于编译之后如果需要修改就需要整个模块重新编译，可移植性较差。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。且安全性不如解释性语言，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）。

代表语言：C、C++、Pascal、Object-C、swift等。

### 解释型语言

> 下面摘自维基百科：
>
> **解释型语言**（英语：Interpreted language）是一种[编程语言](https://zh.wikipedia.org/wiki/编程语言)类型。这种类型的编程语言，会将代码一句一句直接运行，不需要像[编译语言](https://zh.wikipedia.org/wiki/編譯語言)（Compiled language）一样，经过[编译器](https://zh.wikipedia.org/wiki/編譯器)先行编译为[机器代码](https://zh.wikipedia.org/wiki/機器碼)，之后再运行。这种编程语言需要利用[解释器](https://zh.wikipedia.org/wiki/直譯器)，在运行期，动态将代码逐句解释（interpret）为机器代码，或是已经预先编译为机器代码的[子程序](https://zh.wikipedia.org/wiki/子程式)，之后再运行。
>
> 理论上，任何编程语言都可以是编译式，或解释型的。它们之间的区别，仅与程序的应用有关。许多编程语言同时采用编译器与解释器来实现，其中包括[Lisp](https://zh.wikipedia.org/wiki/Lisp)，[Pascal](https://zh.wikipedia.org/wiki/Pascal_(程式語言))，[C](https://zh.wikipedia.org/wiki/C語言)，[BASIC](https://zh.wikipedia.org/wiki/BASIC) 与 [Python](https://zh.wikipedia.org/wiki/Python)。[JAVA](https://zh.wikipedia.org/wiki/JAVA)及[C#](https://zh.wikipedia.org/wiki/C♯)采用混合方式，先将代码编译为[字节码](https://zh.wikipedia.org/wiki/字节码)，在运行时再进行解释。

解释性语言的程序重点在于**不需要编译**，相比编译型语言省了道工序，解释性语言**在运行程序的时候才逐行翻译**。

其优点在于有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。

缺点在于每次运行的时候都要解释一遍，性能上不如编译型语言。

代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby

### 脚本语言

> 下面摘自维基百科：
>
> **脚本语言**（英语：Scripting language）是为了缩短传统的“编写、编译、链接、运行”（edit-compile-link-run）过程而创建的计算机[编程](https://zh.wikipedia.org/wiki/编程)语言。早期的脚本语言经常被称为[批处理](https://zh.wikipedia.org/wiki/批处理)语言或[工作控制语言](https://zh.wikipedia.org/w/index.php?title=工作控制语言&action=edit&redlink=1)。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让[程序员](https://zh.wikipedia.org/wiki/程式設計師)快速完成[程序](https://zh.wikipedia.org/wiki/计算机程序)的编写工作。而[宏语言](https://zh.wikipedia.org/wiki/宏语言)则可视为脚本语言的分支，两者也有实质上的相同之处。
>
> 虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。几乎所有计算机系统的各个层次都有一种脚本语言。包括操作系统层，如[计算机游戏](https://zh.wikipedia.org/wiki/计算机游戏)，[网络应用程序](https://zh.wikipedia.org/wiki/网络应用程序)，字处理文档，网络[软件](https://zh.wikipedia.org/wiki/软件)等。在许多方面，高级[编程语言](https://zh.wikipedia.org/wiki/编程语言)和**脚本语言**之间互相交叉，二者之间没有明确的界限。

脚本语言的特点是程序代码即是最终的执行文件，只是这个过程需要解释器的参与。

所以说脚本语言与解释型语言有很大的联系。脚本语言通常是被解释执行的，而且程序是文本文件。

典型的脚本语言有，JavaScript，Python等。

与脚本语言相对应的是系统语言，他们的区别是：

1、抽象的级别：这是最重要也是最明显示的不同。脚本语言对程序员提供了更高级的抽象。这一点明显表现在：在这种语言自身中，存在有高级的数据结构，如列表和字典结构，和对这种结构简单方便的嵌套和操作。这样可以创建非常成功的程序。

2、类型定义：系统语言通常是强类型和静态类型定义。这就意味着所有变量的类型要在程序中指定，在编译时检查。相反地，脚本语言是最松散的类型定义，完全没有类型声明，并且在运行时进行动态类型检查。

3、执行：系统语言的特点是编译的。程序被编译成可执行的二进制。另一方面，脚本语言的特点是解释，也就是，指令被立即执行，不存在一个编译的中间状态。这就意味着脚本语言是交互式的(你可以在提示符下敲入命令，并且看到结果)，这是另一个巨大的胜利。这样完全将编译过程从编辑-编译-运行循环中去掉了。

4、速度：以上三点是脚本语言一方面在速度与效率， 一方面在易用性与表示式的强大性之间进行折衷的典型例子。这就使得脚本语言的执行速度比系统语言慢一个数量级。这就是对脚本语言诽谤最多的方面。性能的降低不是真正的问题，因为思想是用脚本语言来组合组件，这些组件是用象C  这样的快速系统语言来编写的。所以所有需要运行快速的东西将因为是用快速的语言实现的而运行得快速。脚本语言只用于将东西绑在一起，并且这些通常不是性能的瓶颈(  或如果是，你需要重新检查你的设计)。

**解释型语言和脚本语言的区别**

脚本语言是解释型的语言，也就是解释型语言包括脚本语言。

解释语言是说解释执行的语言，但执行的代码并不一定是文本格式的。

脚本语言的程序是文本文件，并且是解释执行的。

### 小结

通过了解上面的各种语言，各种类型的语言实际上与语言本身并没有太大关系，许多语言类型的界定不在与语言本身，而在于该语言执行的动作。

不是叫你看到哪个语言，就先去思考这是什么类型的。这种问题本身是没有太大意义的。

![](http://img.zhengyua.cn/img/532~{_D]JMDO9S7`2I2@KY8.jpg)

我们不需要注重于区分各种语言类型的不同，我们需要关注的地方在于这种语言的执行方式或者这种执行方式的实现，以此来以更准确的描述方式来体现该语言的实质。

语言是语言，实现是实现。语言只是一组规范。当我们说一门语言是编译或解释型语言的时候通常指它的主流执行方式而已。其实语言本身并无编译解释之分。

## 面向👗

- 面向过程
- 面向对象
- 面向接口
- 面向切面

不同的开发场景有着不同的面向方向，针对不同的需求，我们需要选择出最佳方向。

下面我们通过一个简单的实例来让大家了解一下。

现在假设你拥有两只小猫咪，一只叫做土豆，一只叫做冰冰。

在周六和周日你会与这两只小猫咪分别进行约会。而在约会中会以下这些事情发生。

首先是土豆：

![](http://img.zhengyua.cn/img/53393640882AFE312FF49113733CA1AD.png)

在周六的时候，你们约会会做这些事情：

![](http://img.zhengyua.cn/img/20200724153420.png)

在周日的时候，你们约会会做这些事情：

![](http://img.zhengyua.cn/img/20200724153450.png)

然后是冰冰：

<img src="http://img.zhengyua.cn/img/QQ图片20200724153619.gif" style="zoom:50%;" />

在周六的时候，你们约会会做以下事情：

![](http://img.zhengyua.cn/img/20200724153959.png)

在周日的时候，你们约会会做以下这些事情：

![](http://img.zhengyua.cn/img/20200724153945.png)

不会吧，你们不会真的以为和小猫咪约会和人类或者纸片人一样吧。

![](http://img.zhengyua.cn/img/20200724154440.png)

![](http://img.zhengyua.cn/img/3.jpg)

以上，我们知道以上所有事情后就开始来编程吧

（不会真有人想去约会吧）

![](http://img.zhengyua.cn/img/20200724154727.png)

**面向过程编程**

面向过程比较容易理解，重点在于过程，所以我们代码的每一步都是按着严格的顺序来进行的。

```java
public class CatDate {

    public static void main(String[] args) {
        System.out.println("土豆起床");
        System.out.println("土豆洗澡");
        System.out.println("土豆化妆");
        System.out.println("***************");
        System.out.println("周六：看电影");
        System.out.println("***************");
        System.out.println("土豆卸妆");
        System.out.println("土豆洗澡");
        System.out.println("土豆睡觉");

        System.out.println("土豆起床");
        System.out.println("土豆洗澡");
        System.out.println("土豆化妆");
        System.out.println("***************");
        System.out.println("周日：吃小饼干");
        System.out.println("***************");
        System.out.println("土豆卸妆");
        System.out.println("土豆洗澡");
        System.out.println("土豆睡觉");

        System.out.println("冰冰起床");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰化妆");
        System.out.println("***************");
        System.out.println("周六：听小鸭子的故事");
        System.out.println("***************");
        System.out.println("冰冰卸妆");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰睡觉");
        
        System.out.println("冰冰起床");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰化妆");
        System.out.println("***************");
        System.out.println("周日：一起看书");
        System.out.println("***************");
        System.out.println("冰冰卸妆");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰睡觉");
    }
}
```

**面向对象编程**

面向对象编程语面向过程最大的不同就在于，把“对象”这一概念进行了抽象，所以我们的重点更多的是从对象来进行考虑，比如将土豆和冰冰两个对象抽象出来，约会就可以被理解为与对象执行的动作。

既然是面向对象，所以我们第一步就肯定是构建对象。而周六周日不同的约会就是对象所执行的方法。

- 土豆

```java
public class Tudou {

    public void Saturday(String thing){
        System.out.println("土豆起床");
        System.out.println("土豆洗澡");
        System.out.println("土豆化妆");
        System.out.println("***************");
        System.out.println("周六："+thing);
        System.out.println("***************");
        System.out.println("土豆卸妆");
        System.out.println("土豆洗澡");
        System.out.println("土豆睡觉");
    }

    public void Sunday(String thing){
        System.out.println("土豆起床");
        System.out.println("土豆洗澡");
        System.out.println("土豆化妆");
        System.out.println("***************");
        System.out.println("周日："+thing);
        System.out.println("***************");
        System.out.println("土豆卸妆");
        System.out.println("土豆洗澡");
        System.out.println("土豆睡觉");
    }

}
```

- 冰冰

```java
public class Bingbing {

    public void Saturday(String thing){
        System.out.println("冰冰起床");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰化妆");
        System.out.println("***************");
        System.out.println("周六："+thing);
        System.out.println("***************");
        System.out.println("冰冰卸妆");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰睡觉");
    }

    public void Sunday(String thing){
        System.out.println("冰冰起床");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰化妆");
        System.out.println("***************");
        System.out.println("周日："+thing);
        System.out.println("***************");
        System.out.println("冰冰卸妆");
        System.out.println("冰冰洗澡");
        System.out.println("冰冰睡觉");
    }

}
```

构建好相应对象后，我们就来完成我们这次编程的目的—约会。

```java
public class CatDate {

    public static void main(String[] args) {
        Tudou tudou=new Tudou();
        Bingbing bingbing = new Bingbing();

        //周六
        tudou.Saturday("看电影");
        bingbing.Saturday("听小鸭子的故事“");

        //周日
        tudou.Saturday("吃小饼干");
        bingbing.Sunday("一起看书");

    }
}
```

**面向接口编程**

面向接口编程实际上是对面向对象更高的抽象级别，它的重点不是在于对象，而是在于执行的动作，也就是可以称为接口。所以面向接口编程需要我们关注的是所要执行的有哪些动作本身和动作本身所需要的条件，不用在意执行动作内部的实现方式。

所以在这次约会中我们需要把约会的周六周日当作一种接口，即需要执行的动作。要完成这次编程的目的，我们只需要调用相应的接口就能够实现。

这里我们就需要声明一个接口：

```java
public interface Date {
    void Saturday(String thing);
    void Sunday(String thing);
}
```

而相应的，土豆和冰冰也都已经实现了相应接口。

```java
public class Tudou implements Date{
    @Override
    public void Saturday(String thing){
		//.....
    }
    @Override
    public void Sunday(String thing){
		//......
    }
}
public class Bingbing implements Date{
    @Override
    public void Saturday(String thing){
		//......
    }
    @Override
    public void Sunday(String thing){
		//.......
    }
}
```

最后让我们继续来约会。

```java
public class CatDate {

    public static void main(String[] args) {
        Date tudou=new Tudou();
        Date bingbing = new Bingbing();
        //周六
        tudou.Saturday("看电影");
        bingbing.Saturday("听小鸭子的故事“");
        //周日
        tudou.Saturday("吃小饼干");
        bingbing.Sunday("一起看书");
    }
}
```

**面向切面编程**

这里我们来考虑如何才是面向切面编程呢。

首先我们通过约会的事项可以发现，其中有许多相同的事情，比如：起床、睡觉、化妆等等。而唯一不同的或者我们能够切入的那一点就是约会中要干的具体事项，比如吃小饼干、看电影等。

我们需要的“切面”实际上就是像下面图中所显现的那样。

![image-20200724162459646](C:%5CUsers%5Ctudou%5CPictures%5CMdPhoto%5Cimage-20200724162459646.png)

而切面之外的事情呢，我们就可以交给类似于经纪人的角色来执行，也被称之为代理。所以这次约会的种种事宜除了与土豆和冰冰一起做的事之外的其他事，都全全交给经纪人去打理规划， 而我们只需要和经纪人说明我们要做的具体事项即可。

当然经纪人需要执行的动作与也是和周六周日两个接口相关的，所以经纪人同样可以实现接口。

所以现在我们需要增加一个经纪人类或者代理类。而这个代理类就是为了代理约会的事情，所以说代理类中有约会这一属性。

```java
public class DateProxy implements Date{
    private Date date;
    
    public DateProxy(String CatName){
        if("土豆".equals(CatName)){
            date = new Tudou();
        }else if("冰冰".equals(CatName)){
            date = new Bingbing();
        }
    }
    
    @Override
    public void Saturday(String thing) {
        date.Saturday(thing);
    }

    @Override
    public void Sunday(String thing) {
        date.Saturday(thing);
    }
}
```

然后我们就可以直接来借助经纪人来完成此次约会。

```java
public class CatDate {

    public static void main(String[] args) {
        //土豆的经纪人
        DateProxy tudou=new DateProxy("土豆");
        //冰冰的经纪人
        DateProxy bingbing=new DateProxy("冰冰");
        
        //周六
        tudou.Saturday("看电影");
        bingbing.Saturday("听小鸭子的故事“");

        //周日
        tudou.Saturday("吃小饼干");
        bingbing.Sunday("一起看书");

    }
}
```

我们可以发现这个代理实际上是静态的，因为我们需要提前告知这个代理我们约会的对象有哪些，比如我们在代理类就已经告诉需要代理的对象有土豆和冰冰。而这种代理实际上就被称为静态代理。

当然我们的重点还是在于切面上，但是切面前后的代理实际上可以区分为动态代理和静态代理。

现在就比如这次的约会，我们能不能够不提前告知这个“经纪人”我们约会的对象，万一以后我们约会的对象就变了呢，说不定还有其他的小猫咪呢。

![](http://img.zhengyua.cn/img/20200724170348.png)

这里我们就需要一种叫做动态代理的技术，来帮助我们完成这样一个目的。动态代理的经纪人就能够做到无论我们约会的是哪一只小猫咪，它都能够帮这只小猫咪打理规划除切面之外的其他事情。

```java
public class DateHandler implements InvocationHandler {


    //目标对象：小猫咪
    private Object target;

    public DateHandler(Object target){
        this.target=target;
    }


    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        before(target.getClass().getName());
        Object cat = method.invoke(target,args);
        after(target.getClass().getName());
        return cat;
    }

    private void before(String name){
        System.out.println(name+"起床");
        System.out.println(name+"洗澡");
        System.out.println(name+"化妆");
    }

    private void after(String name){
        System.out.println(name+"卸妆");
        System.out.println(name+"洗澡");
        System.out.println(name+"睡觉");
    }
}

```

最后让我们来通过动态代理来完成这一次的约会。

```java
public class Cat {

    public static void main(String[] args) {
        //创建目标实现类的实例
        Date tudou = new Tudou();
        Date bingbing = new Bingbing();

        //创建动态代理类
        DateHandler tudouHandler = new DateHandler(tudou);
        DateHandler bingbingHandler = new DateHandler(bingbing);

        //召唤动态代理
        Date tudouProxy=(Date) Proxy.newProxyInstance(tudou.getClass().getClassLoader(),tudou.getClass().getInterfaces(),tudouHandler);
        Date bingbingProxy=(Date) Proxy.newProxyInstance(bingbing.getClass().getClassLoader(),bingbing.getClass().getInterfaces(),bingbingHandler);

        tudouProxy.Saturday("看电影");
        bingbingProxy.Saturday("听小鸭子的故事");

        tudouProxy.Saturday("吃小饼干");
        bingbingProxy.Sunday("一起看书");

    }
}
```

通过这一次约会相信大家都成长了许多，只不过对于小猫咪和约会大家还是要明白。

<img src="http://img.zhengyua.cn/img/G$7CF%ICTT4GGJH6$_8I~MN.jpg" style="zoom: 33%;" />

醒醒吧，刚刚我们只是讨论编程而已。

![](http://img.zhengyua.cn/img/VGRG%R$``D30R`QBZZBG~5F.gif)



通过上面的讲解，相信大家应该简单理解了面向过程编程、面向对象编程、面向接口编程、面向切面编程。

虽然例子很生动，但是我们还是需要更书面化地描述来向大家说明这四种面向编程，或者说叫程序设计。

### 面向过程编程

> 下面摘自百度百科：
>
> “面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。

相信大家都接触过C语言，C语言就是面向过程编程的代表性语言。

一般是先析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

### 面向对象编程

> 下面摘自维基百科：
>
> **面向对象程序设计**（英语：Object-oriented programming，[缩写](https://zh.wikipedia.org/wiki/缩写)：OOP）是种具有[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))概念的[程序编程典范](https://zh.wikipedia.org/wiki/编程范型)，同时也是一种程序开发的抽象方针。它可能包含[数据](https://zh.wikipedia.org/wiki/数据)、[属性](https://zh.wikipedia.org/w/index.php?title=属性_(计算机科学)&action=edit&redlink=1)、[代码](https://zh.wikipedia.org/wiki/源代码)与[方法](https://zh.wikipedia.org/wiki/方法_(電腦科學))。对象则指的是[类](https://zh.wikipedia.org/wiki/类_(计算机科学))的实例。它将[对象](https://zh.wikipedia.org/wiki/物件_(電腦科學))作为[程序](https://zh.wikipedia.org/wiki/计算机程序)的基本单元，将程序和[数据](https://zh.wikipedia.org/wiki/数据)[封装](https://zh.wikipedia.org/wiki/封裝_(物件導向程式設計))其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象[[1\]](https://zh.wikipedia.org/wiki/面向对象程序设计#cite_note-1)[[2\]](https://zh.wikipedia.org/wiki/面向对象程序设计#cite_note-2)。
>
> 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列[函数](https://zh.wikipedia.org/wiki/函数)的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。
>
> 当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。在这一方面，我们必须了解更多关于[面向对象系统分析](https://zh.wikipedia.org/wiki/面向对象系统分析)和[面向对象设计](https://zh.wikipedia.org/wiki/面向对象设计)（Object Oriented Design，简称OOD）方面的知识。许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。
>
> 重要的面向对象编程语言包含[Common Lisp](https://zh.wikipedia.org/wiki/Common_Lisp)、[Python](https://zh.wikipedia.org/wiki/Python)、[C++](https://zh.wikipedia.org/wiki/C%2B%2B)、[Objective-C](https://zh.wikipedia.org/wiki/Objective-C)、[Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)、[Delphi](https://zh.wikipedia.org/wiki/Delphi)、[Java](https://zh.wikipedia.org/wiki/Java)、[Swift](https://zh.wikipedia.org/wiki/Swift_(程式語言))、[C#](https://zh.wikipedia.org/wiki/C♯)、[Perl](https://zh.wikipedia.org/wiki/Perl)、[Ruby](https://zh.wikipedia.org/wiki/Ruby) 与 [PHP](https://zh.wikipedia.org/wiki/PHP)等。

面向对象编程最显著的三个特性：

- **继承**
- **封装**
- **多态**

面向对象编程有需要遵循的五大基本原则：

1. **单一职责原则SRP(Single Responsibility Principle)**

   类的功能要单一，不能包罗万象，跟杂货铺似的。

2. **开放封闭原则OCP(Open－Close Principle)**

   一个模块对于拓展是开放的，对于修改是封闭的。

3. **里式替换原则LSP(the Liskov Substitution Principle LSP)**

   子类可以替换父类出现在父类能够出现的任何地方。

4. **依赖倒置原则DIP(the Dependency Inversion Principle DIP)**

   高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

5. **接口分离原则ISP(the Interface Segregation Principle ISP)**

   设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。

### 面向接口编程

> 下面摘自维基百科：
>
> **基于接口编程**（**Interface-based programming**）也称**基于接口的架构**（**interface-based architecture**），它是一种在没有模块系统的[面向对象程序设计](https://zh.wikipedia.org/wiki/面向对象程序设计)语言中的[组件](https://zh.wikipedia.org/wiki/基于组件的软件工程)层面实现[模块化编程](https://zh.wikipedia.org/wiki/模組_(程式設計))的[架构模式](https://zh.wikipedia.org/wiki/架构模式)。符合此例的一个语言是[Java](https://zh.wikipedia.org/wiki/Java)，截至2015年，它没有组件级别的模块系统。Java有一个包（package）系统，但Java软件组件通常由多个Java包组成——并且在任何情况下，接口编程可以提供优于仅使用Java包的优势，即使组件仅由单个Java包组成。
>
> 基于接口的编程将[应用程序](https://zh.wikipedia.org/wiki/应用程序)定义为组件的集合，其中组件间的[应用程序接口](https://zh.wikipedia.org/wiki/应用程序接口)（API）调用可能只通过[抽象化](https://zh.wikipedia.org/wiki/抽象化_(計算機科學))接口完成，而没有具体的[类](https://zh.wikipedia.org/wiki/类_(计算机科学))。类的实例化一般通过使用如[工厂模式](https://zh.wikipedia.org/wiki/工厂方法#工厂)等技术的其他接口完成。
>
> 这种方式被认为增加了应用程序的模块性并因而增加了[可维护性](https://zh.wikipedia.org/w/index.php?title=Maintainability&action=edit&redlink=1)。但是，有必要谨慎考虑——仅将应用程序分解成通过接口通信的任意组件本身不能保证低[耦合性](https://zh.wikipedia.org/wiki/耦合性_(計算機科學))或高[内聚性](https://zh.wikipedia.org/wiki/內聚性_(計算機科學))，这两项通常被认为是可维护性的另外两项关键属性。
>
> 当第三方（或同一个组织内的另一个团队）为已创建的系统开发了额外的组件或插件时，可以使用基于接口体系结构。[Eclipse IDE](https://zh.wikipedia.org/wiki/Eclipse)的代码库就是基于接口编程的一个例子。Eclipse插件插件供应商只需开发满足父应用程序供应商Eclipse基金会指定接口的组件。在Eclipse中，哪怕“Java开发工具”等原始组件本身也是一个插件。这有点像[移动电话](https://zh.wikipedia.org/wiki/移动电话)制造商制定的移动充电器接口（引脚布局、预期[直流电](https://zh.wikipedia.org/wiki/直流電)电压等）和，制造商和第三方都制造符合这种标准接口规范的手机充电器。

简单来说，面向接口编程就是先把客户的业务逻辑线提取出来，**作为接口**，**业务具体实现通过该接口的实现类来完成**。

其最显著的优点就在于**降低程序的耦合度**和**易于程序的扩展**，这样也能够更好的进行**程序的维护**。

一个体有可能有多个抽象面。 **抽象体与抽象面**是有区别的。而接口更多就是作为一个抽象体而存在。

### 面向切面编程

> 下面摘自百度百科：
>
> **面向切面的程序设计**（Aspect-oriented programming，AOP，又译作**面向方面的程序设计**、**剖面导向程序设计**）是[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中的一种[程序设计思想](https://zh.wikipedia.org/wiki/编程范型)，旨在将**横切关注点**与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的**通知**（Advice）机制，能够对被声明为“**切点**（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。
>
> 面向切面的程序设计将代码逻辑切分为不同的模块（即**关注点**（Concern），一段特定的逻辑功能)。几乎所有的编程思想都涉及代码功能的分类，将各个关注点封装成独立的抽象模块（如函数、过程、模块、类以及方法等），后者又可供进一步实现、封装和重写。部分关注点“横切”程序代码中的数个模块，即在多个模块中都有出现，它们即被称作“**横切关注点**（Cross-cutting concerns, Horizontal concerns）”。
>
> 日志功能即是横切关注点的一个典型案例，因为日志功能往往横跨系统中的每个业务模块，即“横切”所有有日志需求的类及方法体。而对于一个信用卡应用程序来说，存款、取款、帐单管理是它的核心关注点，日志和持久化将成为横切整个对象结构的横切关注点。
>
> 切面的概念源于对[面向对象的程序设计](https://zh.wikipedia.org/wiki/面向对象的程序设计)的改进，但并不只限于此，它还可以用来改进传统的函数。与切面相关的编程概念还包括[元对象协议](https://zh.wikipedia.org/w/index.php?title=元对象协议&action=edit&redlink=1)、主题（Subject）、[混入](https://zh.wikipedia.org/w/index.php?title=混入&action=edit&redlink=1)（Mixin）和委托（Delegate）。

面向切面编程中你必须要能够找到其程序之间共通的**切入点**或者**切入面**，横向地去看待程序。

且你的切入必须要保证**不能够影响**其切面之外原有的功能。

### 小结

其实，从这四种面向编程的字面意思就能够体现其编程的重点。

其中面向过程与面向对象更多的是一种思考问题的方式，而面向接口与面向切面则是基于这种问题思考方式的复用技术。

很少说，一个程序是是面向接口或者面向切面编程的，这两者一般是复用在面向对象中所会用到的技术或者设计模型。

面对程序设计，我们不需要关注这个程序是什么编程方式，而是这个程序适合什么编程方式。

## X步与X塞与并X🕵️‍♀️

### 同步与异步🚦

**同步**就是整个处理过程顺序执行，**当各个过程都执行完毕，并返回结果**。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。

**异步**则是只是发送了调用的指令，**调用者无需等待被调用的方法完全执行完毕**；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面。

他们最大大的区别就在于**一个需要等待，一个不需要等待**。

我们来举一个简单的例子来进行说明。

比如今天你已经精疲力尽回到家，然后你的女朋友就会在温柔地询问你

- 请问老公是先吃饭呢还是先洗澡呢？

等等，你好像没有女朋友。

![](http://img.zhengyua.cn/img/J0VSXHOFA5@TIW70Y61N0J.jpg)

那换个入场方式，今天你精疲力尽回到家，你心理在犹豫着是否是先洗澡，还是先吃饭。

如果是按照同步的方式

- 那么你会先去洗澡，然后再去吃饭，或者是先吃饭，然后再去洗澡，反正你只能先把这一样做完才能做下一样

如果是按照异步的方式

- 如果把人当作一个程序，那么你的嘴可以是一个进程，而你的身体也可以是一个进程，两者可以异步地各自执行，那么你就可以一边洗澡一边吃饭

### 阻塞与非阻塞🚧

**阻塞**这个词来自**操作系统**于线程/进程的状态模型中

![](http://img.zhengyua.cn/img/20200724180526.png)



其中的**阻塞调用**就是指调用结果返回之前，调用者会进入阻塞状态等待，只有在得到结果之后才会返回。

而**非阻塞调用**就是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

虽然这听起来同步和阻塞很像，但实际上两个概念。

我们这里还是要强调一点是阻塞来自于线程/进程的状态模型中，所以它一定与线程/进程有关。

所以我们需要明白的是，**同步调用的时候，线程不一定阻塞**。同步的调用虽然没返回，但它还是在运行状态中的，CPU很可能还在执行这段代码，而阻塞的话，它就肯定不在CPU中跑这个代码了。

这就是同步和阻塞的区别。同步是肯定可以在，而阻塞不一定在。

异步和非阻塞的定义也比较像，而两者的区别是

- 异步是说**调用的时候结果不会马上返回**，线程可能被阻塞起来，也可能不阻塞，**两者没关系**。
- 非阻塞是说调用的时候，**线程肯定不会进入阻塞状态**。

### 组合

上面的两组概念，就会得到4中不同的组合。

- **同步阻塞调用：**得不到结果不返回，线程进入阻塞态等待
- **同步非阻塞调用：**得不到结果不返回，线程不阻塞一直在CPU运行
- **异步阻塞调用：**去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞
- **异步非阻塞调用：**去到别的线程，别的线程一直在运行，直到得出结果

别晕，按着自己的思考方式来捋一捋。

![](http://img.zhengyua.cn/img/_3M59W[WK41M~125$P}X}C2.jpg)

### 并发与并行🚂

并发与并行还是来自于操作系统中的概念，这两者简单理解起来就是：

- 并发是指一个时间段内，有几个程序都在同一个CPU上运行，但**任意一个时刻点上只有一个程序在处理机上运行**。
- 并行是指一个时间段内，有几个程序都在几个CPU上运行，任意一个时刻点上，**有多个程序在同时运行**，并且多道程序之间互不干扰。 

你可以这样理解，**并发是“假”的并行**。

为什么会说是假的呢，是因为从宏观上来看我们直接能够感觉到它是**并行**的，但是微观角度上它实际上是**串行**的，这就是CPU调度的强大之处。

![](http://img.zhengyua.cn/img/Q7$J(T3F}{2XT$)EWLZDE1Y.jpg)

## 函数式编程🥓

我知道你又会苦恼，怎么又来了一个什么编程。

![](http://img.zhengyua.cn/img/a84feac99a6cad9fd02759dc7f27421d.gif)





那正好，让我们抱着这样疑惑的态度来认识函数式编程。

### 简介

> 下面摘自维基百科：
>
> **函数式编程**（英语：**functional programming**）或称**函数程序设计**、**泛函编程**，是一种[编程范式](https://zh.wikipedia.org/wiki/编程范式)，它将[电脑运算](https://zh.wikipedia.org/wiki/電腦運算)视为[函数](https://zh.wikipedia.org/wiki/函数)运算，并且避免使用[程序状态](https://zh.wikipedia.org/w/index.php?title=程式状态&action=edit&redlink=1)以及[易变对象](https://zh.wikipedia.org/wiki/不可變物件)。其中，[λ演算](https://zh.wikipedia.org/wiki/Λ演算)（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。
>
> 比起[指令式编程](https://zh.wikipedia.org/wiki/指令式編程)，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。
>
> 在函数式编程中，函数是[第一类对象](https://zh.wikipedia.org/wiki/第一类对象)，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。

函数式编程与之前我们讲到的面向XX编程是不一样的领域。更多的，它是一种**编程范式**。

而这个领域里面会涉及到的编程有指令式编程。

指令式编程我们比较容易理解，就是一条一条指令的执行，比如你写的脚本，就是一个步骤一个步骤地执行。

这也正是命令式编程的理论模型—图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。

而函数式编程的不同之处在于什么地方呢？

简单总结来说就是**函数式编程关心数据的映射，命令式编程关心解决问题的步骤**。

### 举例

如何来理解这个数据的映射呢，我们通过一个例子来进行说明。

比如你在Leetcode上面碰到一道二叉树镜像反转一下。

我们会自然而然地写出下面这段代码。

等等，不会有人没有这个“自然而然“吧。

<img src="http://img.zhengyua.cn/img/ZVZT%SY4~ZC02WE7S8PZB32.jpg" style="zoom:50%;" />

就是下面这段代码，为了简单我这里使用python来写：

```python
def invertTree(root):
    if root is None:
        return None
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
```

我们遇到这个问题时，首先会判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。

而如果是函数式编程呢？

让我们再来审视题目，所谓“翻转二叉树”，也就是需要得到一颗和原来二叉树对称的新二叉树。

这颗新二叉树的特点是每一个节点都递归地和原树相反。

用haskell代码表达出来就是：

```haskell
data Tree a = Nil | Node a (Tree a) (Tree a)
            deriving (Show, Eq)

invert :: Tree a -> Tree a
invert Nil = Nil
invert (Node v l r) = Node v (invert r) (invert l)

def invert(node):
    if node is None:
        return None
    else
        return Tree(node.value, invert(node.right), invert(node.left))
```

这段代码体现的思维，就是旧树到新树的映射——对一颗二叉树而言，它的镜像树就是左右节点递归镜像的树。

所以按照函数式编程的思维，我们是通过**描述一个旧树—>新树的映射来思考** ，而不是描述**从旧树得到新树应该怎样做**来达到目的。

### 优势

那么这样有什么好处呢？

首先，最直观的角度来说

- 函数式风格的代码可以写得很精简，大大减少了键盘的损耗

其次，函数式的代码是“对映射的描述”，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述

> 比如函数和函数之间的映射（比如 [functor](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%87%BD%E5%AD%90)）；比如外部操作到 GUI 之间的映射（就是现在前端热炒的所谓 FRP）。

它的抽象程度可以很高，这就意味着函数式的代码可以更方便的复用。



## 参考

[http://hongyitong.github.io/2019/08/25/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/](http://hongyitong.github.io/2019/08/25/动态语言和静态语言的区别/)

https://blog.csdn.net/yuanmengong886/article/details/52572533

https://www.zhihu.com/question/268303059

https://www.zhihu.com/question/19918532

https://blog.csdn.net/ssh159/article/details/52516986

https://juejin.im/post/5baaecd8e51d451a3f4c16d1

https://blog.csdn.net/shiyong1949/article/details/80854656

https://juejin.im/entry/58ae4636b123db0052b1caf8

https://www.zhihu.com/question/28292740