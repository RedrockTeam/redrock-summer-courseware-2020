# CI/CD

> 下面摘自维基百科
>
>  **持续整合**（英语：Continuous integration，缩写CI），又译为**持续集成**，是一种[软件工程](https://zh.wikipedia.org/wiki/軟體工程)流程，是将所有[软件工程师](https://zh.wikipedia.org/wiki/軟件工程師)对于软件的工作副本持续集成到共享主线（mainline）的一种举措。该名称最早由[[1\]](https://zh.wikipedia.org/wiki/持續整合#cite_note-1)[葛来迪·布区](https://zh.wikipedia.org/wiki/葛來迪·布區)（Grady Booch）在他的[布区方法](https://zh.wikipedia.org/w/index.php?title=布區方法&action=edit&redlink=1)[[2\]](https://zh.wikipedia.org/wiki/持續整合#cite_note-2)中提出，在[测试驱动开发](https://zh.wikipedia.org/wiki/测试驱动开发)（TDD）的作法中，通常还会搭配自动[单元测试](https://zh.wikipedia.org/wiki/单元测试)。持续集成的提出主要是为解决软件进行[系统集成](https://zh.wikipedia.org/wiki/系統整合)时面临的各项问题，[极限编程](https://zh.wikipedia.org/wiki/极限编程)称这些问题为集成地狱（integration hell）。 
>
> 在软件工程中，CI / CD或CICD通常是指持续集成与持续交付或持续部署的组合实践。CI / CD通过强制执行应用程序的构建，测试和部署的自动化，弥合了开发和运营活动与团队之间的差距。现代的DevOps实践涉及软件应用程序在其开发生命周期中的持续开发，持续测试，持续集成，持续部署和持续监控。 

CI/CD 是一种通过在应用开发阶段引入[自动化](https://www.redhat.com/zh/topics/automation/whats-it-automation)来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“[集成地狱](https://www.solutionsiq.com/agile-glossary/integration-hell/)”）。 

具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的**整个生命周期**（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由[开发和运维团队](https://www.redhat.com/zh/topics/devops)以敏捷方式协同支持。 

## CI/CD基本概念

缩略词 CI / CD 具有几个不同的含义。

CI/CD 中的“CI”始终指**持续集成**，它属于**开发人员的自动化流程**。

> 成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。

CI/CD 中的“CD”指的是**持续交付和/或持续部署**，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。

![](C:%5CUsers%5Ctudou%5CPictures%5CMdPhoto%5C20200718194555.png)

CI/CD既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时“持续交付”也包含了持续部署流程。

总的来说，我们不用去纠结语义带来的不同，根据具体的环境有着不同的规范标准，取决于CI/CD的自动化程度，我们可以简单把它理解为

- CI/CD就是**一个流程，用于实现应用开发中的高度持续自动化和持续监控**

### 持续集成

持续集成简单理解为频繁地（一天多次）将代码集成到主干。它的好处主要有两个

- **快速发现错误**。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。
- **防止分支大幅偏离主干**。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。

持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果来确定新代码和原有代码能否正确地集成在一起。


> Martin Fowler 说过，"持续集成并不能消除 Bug，而是让它们非常容易发现和改正。"

![](http://img.zhengyua.cn/img/20200718195442.png)

### 持续交付 （Continuous delivery）

持续交付指的是频繁地将软件的新版本交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。

- 可以看成**持续集成的下一步**

持续交付强调的是不管怎么**更新**，软件是随时随地可以**交付**的。

持续交付是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的**类生产环境**中。

![](http://img.zhengyua.cn/img/20200718201754.png)

比如我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。

### 持续部署 （continuous deployment） 

持续部署是持续交付的下一步，即代码通过评审以后，**自动部署到生产环境中**。

- 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。

持续部署的前提是能自动化完成测试、构建、部署等步骤。

![](C:%5CUsers%5Ctudou%5CPictures%5CMdPhoto%5C20200718200926.png)

## 持续集成操作流程
现在我们来详细了解一下持续集成的操作流程，根据持续集成的设计，代码从提交到生产，整个过程有以下几步。

### 提交

首先第一步就是开发者向代码仓库提交代码，即第一次commit。

### 测试（第一轮）

代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并入主干，就会跑**自动化测试**。

> hook，摘自维基百科
>
> **钩子编程**（hooking），也称作“挂钩”，是[计算机程序设计](https://zh.wikipedia.org/wiki/计算机程序设计)术语，指通过拦截[软件模块](https://zh.wikipedia.org/w/index.php?title=模块化程序设计&action=edit&redlink=1)间的函数调用、[消息传递](https://zh.wikipedia.org/wiki/訊息傳遞_(軟體))、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为**钩子**（hook）。 

测试的种类一般有以下三种：

- 单元测试：针对函数或模块的测试；
- 集成测试：针对整体产品的某个功能的测试，即功能测试；
- 端对端测试：从用户界面直达数据库的全链路测试。

第一轮**至少要跑单元测试**。

### 构建

通过第一轮测试，代码就可以合并进主干即集成成功，就算可以交付了。

交付后，就先进行构建（build），再进入第二轮测试。

> 所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖、配置环境、静态资源等等。 

常见的构建工具有以下几种：

- **Jenkins**
- Travis
- Codeship
- Strider
- Zuul 

上面的构建工具中Jenkins和Strider是开源软件，Travis和Codeship对于开源项目可以免费试用。它们都会将构建和测试在一次运行中执行完成。

### 测试（第二轮）

构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。

作为部署前的最后一次自动化测试，必须是全面测试，其中单元测试和集成测试都会跑，在有条件的情况下也要做端到端测试。

需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。

### 部署

到所有测试已经完毕，说明当前代码已经是一个可以直接部署的版本。

现在我们需要将这个版本的所有文件进行打包部署到生产服务器中，其中自动化部署工具也有很多，如Ansible，Chef等。

### 回滚

一旦当前版本发生问题，就要回滚到上一个版本的构建结果。

## Gitlab

 **GitLab** 是由 GitLab Inc.开发，一款基于 [Git](https://zh.wikipedia.org/wiki/Git) 的完全集成的软件开发平台（fully [集成软件](https://zh.wikipedia.org/w/index.php?title=集成軟體&action=edit&redlink=1) development platform）。另外，GitLab 且具有[wiki](https://zh.wikipedia.org/wiki/Wiki)以及在线编辑、[issue跟踪](https://zh.wikipedia.org/wiki/事务跟踪管理系统)功能、CI/CD 等功能。 

> 从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中。

现在Gitlab CI是Gitlab默认集成的CI功能，通过在项目内 `.gitlab-ci.yaml` 配置文件读取 CI 任务并进行相应处理；GitLab CI 通过其称为 **GitLab Runner 的 Agent 端进行 build 操作**；

- 配置`.gitlab-ci.yml`到项目的根目录
- 配置一个Runner

> Runner本身可以使用多种方式安装，比如使用 Docker 镜像启动；Runner 在进行 build 操作时也可以选择多种 build 环境提供者，比如直接在 Runner 所在宿主机 build、通过新创建虚拟机(vmware、virtualbox)进行 build等；同时 Runner 支持 Docker 作为 build 提供者，即每次 build 会新启动容器进行 build；

.gitlab-ci.yml文件会告诉GitLab Runner 做什么。默认情况下，它运行一个**pipeline**，分为三个阶段：**build，test，deploy**。

你并不需要用到所有的阶段，没有job的阶段会被忽略。

GitLab CI 其大致架构如下：

 ![img](https://img2018.cnblogs.com/blog/420532/201907/420532-20190708110723940-1784200475.png)

 

### 基本概念

#### pipline

一次Pipline其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、进行测试、编译、部署测试服务器、部署生产服务器等流程。

在Gitlab中任何提交或者合并主干都可以触发Pipline。

![](C:%5CUsers%5Ctudou%5CPictures%5CMdPhoto%5C20200718204011.png)



#### Stages

Stages阶段即为构建阶段，就Pipline中的每一个流程步骤，一个Pipline中可以定义多个Stages。

这些Stages会有以下特点：

- 所有Stages会按照顺序运行，即当一个Stage完成后再会开始下一个Stage；
- 只有当所有Stages完成后，该Pipline才会成功；
- 任何一个Stage失败则构建任务就会失败即Pipline失败

![](http://img.zhengyua.cn/img/20200718204739.png)

#### Jobs

Jobs就是比Stages更小的单位，表示构建工作。一个Stage中可以定义多个Jobs。

这些Jobs会有以下特点：

- 相同 Stage 中的 Jobs 会并行执行
- 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功
- 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败

![](http://img.zhengyua.cn/img/20200718205007.png)

## 参考

 https://juejin.im/post/5cd28a7ff265da039e20093d#heading-0 

 https://www.redhat.com/zh/topics/devops/what-is-ci-cd 

 https://www.cnblogs.com/sunsky303/p/10775126.html 